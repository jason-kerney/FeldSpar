{"name":"Feldspar","tagline":"Opinionated Purely Functional Unit Test Framework","body":"**Feld Spar F#**\r\n=========\r\n> An opinionated test framework designed to be functional from the ground up.\r\n\r\n###[![Build status](https://ci.appveyor.com/api/projects/status/b5xo1bn8nxr7h06q?svg=true)](https://ci.appveyor.com/project/jason-kerney/feldspar)\r\n\r\n## Available on Nuget\r\n\r\n### [![NuGet Status](http://img.shields.io/nuget/v/FeldSparFramework.svg?style=flat)](https://www.nuget.org/packages/FeldSparFramework/) -- Framework\r\n### [![NuGet Status](http://img.shields.io/nuget/v/FeldSpar.ContinuousIntegration.svg?style=flat)](https://www.nuget.org/packages/FeldSpar.ContinuousIntegration/) -- CI Runner\r\n\r\n-----------------\r\n## What's Different\r\n\r\n1. Function Paradigm from the start\r\n3. Random Test Execution\r\n4. Not a xUnit Clone\r\n\r\n----------------- \r\n##Example\r\n### How to write a unit test\r\n\r\n```fsharp\r\nmodule BasicTests =\r\nopen FeldSpar.Framework\r\nopen FeldSpar.Framework.Verification\r\nopen FeldSpar.Framework.Verification.ApprovalSupport\r\n\r\n    let ``Adding 6 and 4 equals 10`` = \r\n        Test((fun _ ->\r\n                let x = 6\r\n                let y = 4\r\n\r\n               // Before version 0.5\r\n               // (x + y) expectsToBe 10 \"Addition failed 6 + 4 <> %d but did equal %d\"\r\n\r\n               // After version 0.5\r\n               (x + y) expectsToBe 10\r\n            ))\r\n              \r\n    let ``A test with multiple checks to deterime a good result`` =\r\n        Test((fun _ ->\r\n                let x = 6\r\n                let y = 4\r\n                let z = x + y\r\n                \r\n                verify\r\n                    {\r\n                        // Before version 0.5\r\n                        // let! goodX = x expectsToBe 6 \"x failed expected %d but got %d\"\r\n                        // let! goodY = y expectsToBe 4 \"y failed expected %d but got %d\"\r\n                        // let! goodZ = z expectsToBe 10 \"(x + y) failed expected %d but got %d\"\r\n\r\n                        // After version 0.5\r\n                        let! goodX = x expectsToBe 6 |> withFailComment \"x was wrong\"\r\n                        let! goodY = y expectsToBe 4 |> withFailComment \"y was wrong\"\r\n                        let! goodZ = z expectsToBe 10 |> withFailComment \"z was wrong\"\r\n                        return Success\r\n                    }\r\n            ))\r\n            \r\n    (*This is how you quickly ignore a test*)\r\n    let ``This test is not ready yet and therefore is ignored`` =\r\n        ITest(fun env -> Success)\r\n        \r\n    let ``Gold Standard Tests look like this for strings`` =\r\n        Test(fun env ->\r\n                let env = env |> addReporter<ApprovalTests.Reporters.DiffReporter>\r\n                \r\n                \"My string under test\" |> checkAgainstStringStandard env\r\n            )\r\n\r\n    let ``This is a Combinatory Gold Standard Testing`` =\r\n        Test(fun env ->\r\n            let names = [\"Tom\"; \"Jane\"; \"Tarzan\"; \"Stephanie\"]\r\n            let amounts = [11; 2; 5;]\r\n            let items = [\"pears\";\"earrings\";\"cups\"]\r\n\r\n            let createSentance item amount name = sprintf \"%s has %d %s\" name amount item\r\n\r\n            createSentance\r\n                |> calledWithEachOfThese items\r\n                |> andAlsoEachOfThese amounts\r\n                |> andAlsoEachOfThese names\r\n                |> checkAllAgainstStandard env\r\n        )\r\n\r\n    let ``This is a theory Test`` =\r\n        Theory({\r\n                    Data = [\r\n                                (1, \"1\");\r\n                                (2, \"2\");\r\n                                (3, \"Fizz\");\r\n                                (5, \"Buzz\");\r\n                                (6, \"Fizz\");\r\n                                (10,\"Buzz\");\r\n                                (15,\"FizzBuzz\")\r\n                    ] |> List.toSeq\r\n                    Base = \r\n                    {\r\n                        UnitDescription = (fun (n,s) -> sprintf \"test converts %d into \\\"%s\\\"\" n s)\r\n                        UnitTest = \r\n                            (fun (n, expected) _ ->\r\n                                let result = \r\n                                    match n with\r\n                                    | v when v % 15 = 0 -> \"FizzBuzz\"\r\n                                    | v when v % 5 = 0 -> \"Buzz\"\r\n                                    | v when v % 3 = 0 -> \"Fizz\"\r\n                                    | v -> v.ToString()\r\n\r\n                                result |> expectsToBe expected\r\n                            )\r\n                    }\r\n        })\r\n            \r\n    let ``Division Theory`` = \r\n        {\r\n            UnitDescription = (fun n -> sprintf \" (%f * %f) / %f = %f\" n n n n)\r\n            UnitTest = (fun n _ ->\r\n                            let v1 = n ** 2.0\r\n                            let result = v1 / n\r\n\r\n                            result |> expectsToBe n \"(%f <> %f)\"\r\n            )\r\n        }\r\n          \r\n    let ``Whole Doubles from 1.0 to 20.0`` = seq { 1.0..20.0 }  \r\n\r\n    let ``Here is a second theory test`` =\r\n        Theory({\r\n                Data = ``Whole Doubles from 1.0 to 20.0``\r\n                Base = ``Division Theory``\r\n        })\r\n```\r\n\r\n### How to _(currently)_ run all tests\r\n\r\n* Install FeldSparFramework from nuget\r\n* Change your test project to be start up project\r\n* Hit F5\r\n\r\n### OR:\r\n* Run FeldSpar.Console.exe with these args\r\n\r\n#### Console args\r\n```console\r\n\r\n--test-assembly [--a] <string>: This is the location of the test library. It can be a *.dll or a *.exe file\r\n\r\n--report-location [--r] <string>: This flag indicates that a JSON report is to be generated at the given location\r\n\r\n--verbosity [--v] <string>: This sets the verbosity level for the run. Possible levels are: [\"Max\"; \"Results\"; \"Errors\"; \"Detail\"]\r\n\r\n--usereporters [--ur]: This enables the use of reporters configured in the test\r\n\r\n--help [-h|/h|/help|/?]: display this list of options.\r\n\r\n```\r\n\r\n##Goals\r\n### 1. Be as purely functional as possible\r\n### 2. Enforce Test Isolation\r\n\r\n* _(done)_ Test execution order is indeterminate\r\n\r\n### 3. Enable Gold Standard Testing as a Framework Feature\r\n* _(done)_ Enable use of Approval Libraries in a functional manner\r\n* _(done)_ Enable Configuration to setup global reporters for test Assembly.\r\n\r\n### 4. Implement Theory Based Testing\r\n* _(done)_ Theory test type\r\n\r\n### 5. Integrate with visual studio\r\n\r\n### 6. Create Console Runner\r\n* _(done)_ Create parameterized console\r\n\r\n### 7. Generate Documentation\r\n* Add XML Comments\r\n* _(done)_ Add Read Me\r\n\r\n## Design Considerations\r\n### **NO** Exception Driven Workflows\r\n> OO based test frameworks use `Assert` to designate a failure. This works because it generates an exception which forces an early exit without `if` `then` `else` or `case` statements.\r\n\r\n> Functional programming has a better way. In F# that way is called a workflow. Every test **must** return a valid type indicating its success or failure. In FeldSpar that type is a `TestResult`.\r\n\r\n> Exceptions happen. The Framework will handle them, however they should be an exception to the normal rule.\r\n\r\n### Ignored Tests are failing tests\r\n> In other frameworks an ingnored test simply does not run and reports itself as being in a third state if _ignored_. Ignoring a test is a failure. It is a failure of either the test or test methodologies.\r\n\r\n> By having an ignored state you increase complexity of the system because there are three states of a test.\r\n\r\n> Feld Spar tackles this by having only 2 states of a test. Success or Failure. Failures allow you to have a reason for failure, which will be `Ignored` for an ignored test.\r\n\r\n### Favor Intention\r\n> .Net attributes are not immediately obvious when your program execution depends on them. If you find a method that conforms to the test signature but lacks the attribute was the attribute removed?\r\n\r\n> I wanted a test framework that made a test method as obviously indented to be a test.\r\n\r\n> I also choose a convention based approach whenever I was able to without forfeiting clarity\r\n\r\n## Feld Spar?\r\n> Vikings navigated using solar navigation. This presented a problem when it was foggy, overcast or rainy. However they were very successful at navigation despite these limitations. Myth states that the Vikings had a magic [Sun Stone](http://news.discovery.com/earth/rocks-fossils/viking-sunstone-shipwreck-130311.htm) that enabled them to navigate during the worst of weather.\r\n  \r\n> Recent discoveries have shown that the Viking Sun Stone was not a myth. It was a type of stone known as Icelantic Spar which is in tern a type of Feld Spar.\r\n  \r\n> Unit tests guide us out of the worst situations. And so I named my framework after the tool that guided the Vikings out of the worst weather.\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}